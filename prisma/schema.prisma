generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SourceType {
  vcenter
  pve
  hyperv
  aliyun
  third_party
}

enum RunTriggerType {
  schedule
  manual
}

enum RunMode {
  collect
  collect_hosts
  collect_vms
  detect
  healthcheck
}

enum RunStatus {
  Queued
  Running
  Succeeded
  Failed
  Cancelled
}

enum UserRole {
  admin
  user
}

enum AssetType {
  vm
  host
  cluster
}

enum AssetStatus {
  in_service
  offline
  merged
}

enum AssetPresenceStatus {
  present
  missing
}

enum DuplicateCandidateStatus {
  open
  ignored
  merged
}

enum DuplicateCandidateJobStatus {
  Queued
  Running
  Succeeded
  Failed
}

enum MergeConflictStrategy {
  primary_wins
  latest_wins
  manual_pick
}

enum RelationType {
  runs_on
  member_of
  hosts_vm
}

enum RelationStatus {
  active
  inactive
}

model ScheduleGroup {
  id                 String    @id @default(cuid())
  name               String    @unique
  enabled            Boolean   @default(true)
  timezone           String
  runAtHhmm          String
  maxParallelSources Int?
  lastTriggeredOn    DateTime? @db.Date
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  sources Source[]
  runs    Run[]

  @@index([enabled])
}

model Credential {
  id                String     @id @default(cuid())
  name              String     @unique
  type              SourceType
  payloadCiphertext String
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  sources Source[]
}

model Source {
  id              String         @id @default(cuid())
  name            String
  sourceType      SourceType
  enabled         Boolean        @default(true)
  scheduleGroupId String?
  scheduleGroup   ScheduleGroup? @relation(fields: [scheduleGroupId], references: [id])

  // Non-sensitive config (JSON). Credentials should be encrypted/kept elsewhere.
  config               Json?
  credentialCiphertext String?
  credentialId         String?
  credential           Credential? @relation(fields: [credentialId], references: [id], onDelete: Restrict)
  deletedAt            DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  runs Run[]

  assetLinks     AssetSourceLink[]
  sourceRecords  SourceRecord[]
  relationRecords RelationRecord[]
  relations      Relation[]

  @@index([enabled])
  @@index([scheduleGroupId])
  @@index([credentialId])
}

model Run {
  id              String  @id @default(cuid())
  sourceId        String
  scheduleGroupId String?

  triggerType RunTriggerType
  mode        RunMode
  status      RunStatus      @default(Queued)

  startedAt  DateTime?
  finishedAt DateTime?

  detectResult Json?
  stats        Json?
  warnings     Json?
  errors       Json?
  errorSummary String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  source        Source         @relation(fields: [sourceId], references: [id])
  scheduleGroup ScheduleGroup? @relation(fields: [scheduleGroupId], references: [id])

  sourceRecords   SourceRecord[]
  relationRecords RelationRecord[]
  assetSnapshots  AssetRunSnapshot[]
  lastSeenLinks   AssetSourceLink[] @relation("AssetSourceLinkLastSeenRun")
  duplicateCandidateJob DuplicateCandidateJob?

  @@index([status, createdAt])
  @@index([sourceId, status, createdAt])
  @@index([scheduleGroupId, status, createdAt])
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  role         UserRole @default(admin)
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  sessions                 Session[]
  auditEvents              AuditEvent[]        @relation("AuditActor")
  mergeAudits              MergeAudit[]        @relation("MergeAuditActor")
  preferences              UserPreference[]
  ignoredDuplicateCandidates DuplicateCandidate[] @relation("DuplicateCandidateIgnoredBy")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model AuditEvent {
  id          String   @id @default(cuid())
  eventType   String
  actorUserId String?
  payload     Json
  createdAt   DateTime @default(now())

  actorUser User? @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([eventType, createdAt])
  @@index([actorUserId, createdAt])
}

model MergeAudit {
  id                String                @id @default(cuid())
  primaryAssetUuid  String                @db.Uuid
  mergedAssetUuid   String                @db.Uuid
  performedByUserId String?
  performedAt       DateTime              @default(now())
  conflictStrategy  MergeConflictStrategy @default(primary_wins)
  summary           Json
  snapshotRef       String?

  primaryAsset     Asset @relation("MergeAuditPrimary", fields: [primaryAssetUuid], references: [uuid], onDelete: Cascade)
  mergedAsset      Asset @relation("MergeAuditMerged", fields: [mergedAssetUuid], references: [uuid], onDelete: Cascade)
  performedByUser  User? @relation("MergeAuditActor", fields: [performedByUserId], references: [id], onDelete: SetNull)

  @@index([primaryAssetUuid, performedAt(sort: Desc)])
  @@index([mergedAssetUuid, performedAt(sort: Desc)])
  @@index([performedByUserId, performedAt(sort: Desc)])
}

model UserPreference {
  id        String   @id @default(cuid())
  userId    String
  key       String
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key])
  @@index([userId])
}

model Asset {
  uuid              String      @id @default(uuid()) @db.Uuid
  assetType          AssetType
  displayName        String?
  // Manual override for "机器名" display; does not block canonical collection from being stored.
  machineNameOverride String?
  status             AssetStatus @default(in_service)
  mergedIntoAssetUuid String?    @db.Uuid
  lastSeenAt         DateTime?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  mergedIntoAsset Asset?  @relation("AssetMerge", fields: [mergedIntoAssetUuid], references: [uuid])
  mergedAssets    Asset[] @relation("AssetMerge")

  sourceLinks   AssetSourceLink[]
  sourceRecords SourceRecord[]
  runSnapshots  AssetRunSnapshot[]

  outgoingRelations Relation[] @relation("RelationFrom")
  incomingRelations Relation[] @relation("RelationTo")
  duplicateCandidatesA DuplicateCandidate[] @relation("DuplicateCandidateA")
  duplicateCandidatesB DuplicateCandidate[] @relation("DuplicateCandidateB")
  mergeAuditsAsPrimary MergeAudit[] @relation("MergeAuditPrimary")
  mergeAuditsAsMerged  MergeAudit[] @relation("MergeAuditMerged")

  @@index([assetType])
  @@index([status])
  @@index([lastSeenAt])
}

model AssetSourceLink {
  id           String    @id @default(cuid())
  assetUuid    String    @db.Uuid
  sourceId     String
  externalKind AssetType
  externalId   String
  firstSeenAt  DateTime  @default(now())
  lastSeenAt   DateTime  @default(now())
  presenceStatus AssetPresenceStatus @default(present)
  lastSeenRunId   String?

  asset  Asset  @relation(fields: [assetUuid], references: [uuid], onDelete: Cascade)
  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  lastSeenRun Run? @relation("AssetSourceLinkLastSeenRun", fields: [lastSeenRunId], references: [id], onDelete: SetNull)

  sourceRecords SourceRecord[]

  @@unique([sourceId, externalKind, externalId])
  @@index([assetUuid])
  @@index([sourceId])
  @@index([presenceStatus, lastSeenAt(sort: Desc)])
}

model SourceRecord {
  id          String   @default(cuid())
  collectedAt DateTime @default(now())

  runId        String
  sourceId     String
  linkId       String
  assetUuid    String    @db.Uuid
  externalKind AssetType
  externalId   String

  normalized      Json
  raw             Bytes
  rawCompression  String
  rawSizeBytes    Int
  rawHash         String
  rawMimeType     String?
  rawInlineExcerpt String?
  createdAt       DateTime @default(now())

  run    Run           @relation(fields: [runId], references: [id], onDelete: Cascade)
  source Source        @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  link   AssetSourceLink @relation(fields: [linkId], references: [id], onDelete: Cascade)
  asset  Asset         @relation(fields: [assetUuid], references: [uuid], onDelete: Cascade)

  @@id([id, collectedAt])
  @@index([runId])
  @@index([linkId])
  @@index([assetUuid, collectedAt(sort: Desc)])
  @@index([sourceId, collectedAt(sort: Desc)])
}

model RelationRecord {
  id          String   @default(cuid())
  collectedAt DateTime @default(now())

  runId      String
  sourceId   String
  relationId String?

  relationType RelationType
  fromAssetUuid String @db.Uuid
  toAssetUuid   String @db.Uuid

  raw              Bytes
  rawCompression   String
  rawSizeBytes     Int
  rawHash          String
  rawMimeType      String?
  rawInlineExcerpt String?
  createdAt        DateTime @default(now())

  run      Run       @relation(fields: [runId], references: [id], onDelete: Cascade)
  source   Source    @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  relation Relation? @relation(fields: [relationId], references: [id], onDelete: SetNull)

  @@id([id, collectedAt])
  @@index([runId])
  @@index([sourceId])
  @@index([relationType, fromAssetUuid, toAssetUuid])
  @@index([collectedAt])
}

model Relation {
  id            String        @id @default(cuid())
  relationType  RelationType
  fromAssetUuid String        @db.Uuid
  toAssetUuid   String        @db.Uuid
  sourceId      String
  firstSeenAt   DateTime      @default(now())
  lastSeenAt    DateTime      @default(now())
  status        RelationStatus @default(active)

  fromAsset Asset @relation("RelationFrom", fields: [fromAssetUuid], references: [uuid], onDelete: Cascade)
  toAsset   Asset @relation("RelationTo", fields: [toAssetUuid], references: [uuid], onDelete: Cascade)
  source    Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  records RelationRecord[]

  @@unique([relationType, fromAssetUuid, toAssetUuid, sourceId])
  @@index([sourceId])
  @@index([relationType, fromAssetUuid])
  @@index([relationType, toAssetUuid])
}

model AssetRunSnapshot {
  id        String   @id @default(cuid())
  assetUuid String   @db.Uuid
  runId     String
  canonical Json
  createdAt DateTime @default(now())

  asset Asset @relation(fields: [assetUuid], references: [uuid], onDelete: Cascade)
  run   Run   @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@unique([assetUuid, runId])
  @@index([runId])
}

model DuplicateCandidate {
  id         String                  @id @default(cuid())
  assetUuidA String                  @db.Uuid
  assetUuidB String                  @db.Uuid
  score      Int
  reasons    Json
  status     DuplicateCandidateStatus @default(open)
  lastObservedAt DateTime            @default(now())

  ignoredByUserId String?
  ignoredAt       DateTime?
  ignoreReason    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  assetA Asset @relation("DuplicateCandidateA", fields: [assetUuidA], references: [uuid], onDelete: Cascade)
  assetB Asset @relation("DuplicateCandidateB", fields: [assetUuidB], references: [uuid], onDelete: Cascade)
  ignoredByUser User? @relation("DuplicateCandidateIgnoredBy", fields: [ignoredByUserId], references: [id], onDelete: SetNull)

  @@unique([assetUuidA, assetUuidB])
  @@index([status, lastObservedAt(sort: Desc)])
}

model DuplicateCandidateJob {
  id           String                    @id @default(cuid())
  runId        String                    @unique
  status       DuplicateCandidateJobStatus @default(Queued)
  attempts     Int                       @default(0)
  startedAt    DateTime?
  finishedAt   DateTime?
  errorSummary String?
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt

  run Run @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
}
